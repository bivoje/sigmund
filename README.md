Ziggerish
======================

Brainfuck compiler written in Zig.

### Build

This project is tested with [`zig-linux-x86_64-0.10.0-dev.479+5e60ee412`](https://ziglang.org/builds/zig-linux-x86_64-0.10.0-dev.479+5e60ee412.tar.xz).

Compatibility with other versions of zig is not known.

Download and install zig compiler then
```
zig build
```
will create the executable in `zig-out/bin/ziggerish`.

### Example

#### Hello world

Simple hello world program copied from wikipedia page
```
zig build run -- samples/hello.bf : ?target=linux_x86_64 ?alloc=7 : ll : main
```

#### Life

life automaton simulator written by Linus Akesson
found at [here](http://www.linusakesson.net/programming/brainfuck/index.php).
```
ziggerish samples/hello.bf : ?target=linux_x86_64 ?alloc=-1000 : as : hello
```

#### DBFI

shorted brainfuck interpreter written in brainfuck
found at [here](https://esolangs.org/wiki/Dbfi).
```
ziggerish samples/dbfi.bf : ?target=linux_x86 : gcc +inlined -libc : dbfi
(cat samples/hello.bf; echo -n '!') | ./dbfi
```

### Usage

```
ziggerish <source> : <general_options> : <method> <method_options> : <dest>
```

`ziggerish` gets compile options from commandline arguments in unconventional, structured way.

4 fields being colon (`:`) separated are required where each can be left omitted for default value.

Note that you can't omit space between colons and give `ziggerish a.bf ::: a.out`,
as parameters are tokenized by whitespaces in current implimentation.

#### source and dest

Simply specify source path and destination path.

In current implementation, when multiple paths are given, only the last one is recognized.

#### general options

Unlike other unix programs, options have the form `?<key>=<value>`.

If the value is boolean you can use syntactic sugar `+<key>` for `true` or `-<key>` for `false`.

The possible options are:
- verbose: = false, true
  boolean sitch for verbose output while compilation
- warning: = true, false
  boolean switch for print warning while compilation
- alloc: 1000, isize
  how to allocate cells buffer in memory.
  + positive integer: static allocation of given size, buffer range checked
  + negative integer: static allocation of given size, buffer range unchecked
  + 0: dynamic allocation, buffer grows as needed. no supported for llvm, gcc with nolibc
- eof_by: noop, neg1, zero
  what `,` instruction do when EOF encountered. there are no consensus for behavior on EOF,
  so each bf code assumes one of the options listed above.
  selecting the wrong option may result in unexpected behavior of compiled program.
  + noop: does nothing leaves the cell unchanged
  + neg1: sets the cell value to 255 (-1)
  + zero: sets the cell value to 0
- target: linux_x86_64, linux_x86
  march of target object file.

#### method and method options

`<method>` selects which backends to use while compiling.
`<method_options>` has same format as `<general_options>` while supported keys are method specific.

Currently suppoted methods are
- gcc
  generate C code and use `gcc` to produce an executable.
  + inlined: false, true
    boolean flag to inline routines for brainfuck instructions.
    currently, only `.` and `,` are effected, and `>` and `<` are inlined regardlessly.
  + libc: true, false
    boolean flag to use standard libc. without it, the compiler uses syscall directly.
    with this flag on, the code cannot be inlined, in current implementation
  + temp_path: temp.c, string
    temporary path for geneated c code
- as
  generate AT&T assembly code and uses `as` and `ld` to produce an executable.
  + temp_path_s: temp.s, string
    temporary path for assembly code
  + temp_path_o: temp.o, string
    temporary path for object file that is generated by `as`
- ll
  generate llvm code and use `clang` to produce an execuable.
  + temp_path_ll: temp.ll, string
    temporary path for llvm code

### other links

- [bfc](https://bfc.wilfred.me.uk/): utterly over-engineered brainfuck compiler written in Rust.

### TODO

[ ] impliment streamed input/output

[ ] --help option?

[ ] better, detailed error message.
    use enum-either rather than error set

[ ] support intel assembly syntax?

[ ] organize tests

[ ] add tests

[ ] optimizaion
    use ir (add 4 etc..) <- need to ge/le rather than ne for boundary check

[ ] remove unnecessary -q instr, it inflates machine code size

[ ] boundary check when accessing the value rather than moving the pointer

[ ] writer monad, funcionize code snippet generation
    parameterize registers in compile_as

[ ] what if compilation takes too long? < like kernel compile?
    memory management use other than arena

[ ] windows binary support

[ ] resolve TODOs and FIXMEs

[ ] impliment inotifywait in build.zig
    `inotifywait src` is too noisy, as vim never just writes to the file
          vim creates and writes to filename~ file stead of the file itself
          and then deletes original and moves the file
          with auto saves and temp files, this behavior makes watch-test run multiple times

[ ] enable compiling with debugging infos

[ ] verbos compiling (dump option only if)

[ ] compile pipeline design

[ ] option for how to handle temp files?

[ ] immediate executable generation

[ ] inline asm. it inflates exe size but may have better performance as there's less jumps.

[ ] alloc=dynamic in c-nostdlib/llvm using alloca().
